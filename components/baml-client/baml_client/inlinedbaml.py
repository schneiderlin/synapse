# ----------------------------------------------------------------------------
#
#  Welcome to Baml! To use this generated code, please run the following:
#
#  $ pip install baml
#
# ----------------------------------------------------------------------------

# This file was generated by BAML: please do not edit it. Instead, edit the
# BAML files and re-generate this code using: baml-cli generate
# baml-cli is available with the baml package.

_file_map = {

    "chat.baml": "function ChatAgent(messages: Message[]) -> string {\r\n  client \"GLMCodingA\"\r\n  prompt #\"\r\n    {{ _.role(\"system\") }}\r\n\r\n    You are a chat agent that can chat with the user.\r\n    {% for msg in messages %}\r\n    {{ _.role(msg.role) }} {{ msg.content }}\r\n    {% endfor %}\r\n    \"#\r\n}\r\n\r\ntest chat_agent {\r\n  functions [ChatAgent]\r\n  args {\r\n    messages [{\r\n      role \"user\"\r\n      content \"hello\"\r\n    }]\r\n  }\r\n}\r\n",
    "clients.baml": "client<llm> GLMCodingA {\r\n  provider \"anthropic\"\r\n  options {\r\n    base_url \"https://api.z.ai/api/anthropic\"\r\n    api_key env.ZAI_API_KEY\r\n    model \"GLM-4.7\"\r\n  }\r\n}\r\n\r\nclient<llm> FreeGLM45Air {\r\n  provider \"openai-generic\"\r\n  options {\r\n    base_url \"https://openrouter.ai/api/v1\"\r\n    api_key env.OPENROUTER_API_KEY\r\n    model \"z-ai/glm-4.5-air:free\"\r\n  }\r\n}\r\n\r\nclient<llm> LMStudioQWen3Coder {\r\n  provider \"openai-generic\"\r\n  options {\r\n    base_url \"http://localhost:1234/v1\"\r\n    model \"qwen/qwen3-coder-30b\"\r\n  }\r\n}\r\n\r\n// client<llm> LMStudioQWen34B {\r\n//   provider \"openai-generic\"\r\n//   options {\r\n//     base_url \"http://localhost:1234/v1\"\r\n//     model \"qwen/qwen3-coder-30b\"\r\n//   }\r\n// }\r\n\r\n// https://docs.boundaryml.com/docs/snippets/clients/retry\r\nretry_policy Constant {\r\n  max_retries 3\r\n  strategy {\r\n    type constant_delay\r\n    delay_ms 200\r\n  }\r\n}\r\n\r\nretry_policy Exponential {\r\n  max_retries 2\r\n  strategy {\r\n    type exponential_backoff\r\n    delay_ms 300\r\n    multiplier 1.5\r\n    max_delay_ms 10000\r\n  }\r\n}\r\n",
    "code_locator.baml": "class GrepTool {\r\n  name \"grep\"\r\n  pattern string @description(\"The regex pattern to search for in file contents\")\r\n  path string? @description(\"Optional directory path to search within. If not provided, searches entire codebase\")\r\n  type string? @description(\"Optional file type filter (e.g., 'js', 'py', 'ts')\")\r\n}\r\n\r\nclass GlobTool {\r\n  name \"glob_file_search\"\r\n  glob_pattern string @description(\"The glob pattern to match filenames (e.g., '*test*.js', '*.config.*')\")\r\n  target_directory string? @description(\"Optional directory to search within. If not provided, searches entire codebase\")\r\n}\r\n\r\nclass ListDirTool {\r\n  name \"list_dir\"\r\n  target_directory string? @description(\"Optional directory path to list contents of. If not provided, lists current directory\")\r\n}\r\n\r\nclass LocatorDecision {\r\n  explanation string? @description(\"Optional explanation of the search strategy or findings\")\r\n  tool (GrepTool | GlobTool | ListDirTool)? @description(\"Single tool to execute for searching the codebase. Use when you need to search. Execute one tool at a time.\")\r\n  findings string? @description(\"Final structured output with organized file locations. Use this after tools have been executed and you have results to organize. Format as markdown with sections: Implementation Files, Test Files, Configuration, Type Definitions, Related Directories, Entry Points.\")\r\n}\r\n\r\nfunction CodeLocator(messages: Message[]) -> LocatorDecision {\r\n    client \"FreeGLM45Air\"\r\n    prompt #\"\r\n        You are a specialist at finding WHERE code lives in a codebase. Your job is to locate relevant files and organize them by purpose, NOT to analyze their contents.\r\n\r\n    ## CRITICAL: YOUR ONLY JOB IS TO DOCUMENT AND EXPLAIN THE CODEBASE AS IT EXISTS TODAY\r\n    - DO NOT suggest improvements or changes unless the user explicitly asks for them\r\n    - DO NOT perform root cause analysis unless the user explicitly asks for them\r\n    - DO NOT propose future enhancements unless the user explicitly asks for them\r\n    - DO NOT critique the implementation\r\n    - DO NOT comment on code quality, architecture decisions, or best practices\r\n    - ONLY describe what exists, where it exists, and how components are organized\r\n\r\n    ## Core Responsibilities\r\n\r\n    1. **Find Files by Topic/Feature**\r\n    - Search for files containing relevant keywords\r\n    - Look for directory patterns and naming conventions\r\n    - Check common locations (src/, lib/, pkg/, etc.)\r\n\r\n    2. **Categorize Findings**\r\n    - Implementation files (core logic)\r\n    - Test files (unit, integration, e2e)\r\n    - Configuration files\r\n    - Documentation files\r\n    - Type definitions/interfaces\r\n    - Examples/samples\r\n\r\n    3. **Return Structured Results**\r\n    - Group files by their purpose\r\n    - Provide full paths from repository root\r\n    - Note which directories contain clusters of related files\r\n\r\n    **How to use tools:**\r\n    1. Execute one tool at a time - return a single tool in the `tool` field\r\n    2. Start with `GrepTool` to find files containing relevant keywords related to the feature/topic\r\n    3. Use `GlobTool` to find files matching common naming patterns (e.g., `*service*`, `*handler*`, `*test*`)\r\n    4. Use `ListDirTool` to explore directories that might contain related files\r\n    5. After each tool execution, you'll receive results and can decide to use another tool or organize findings\r\n    6. You can include an optional `explanation` to describe your search strategy\r\n\r\n    ## Search Strategy\r\n\r\n    ### Initial Broad Search\r\n\r\n    First, think deeply about the most effective search patterns for the requested feature or topic, considering:\r\n    - Common naming conventions in this codebase\r\n    - Language-specific directory structures\r\n    - Related terms and synonyms that might be used\r\n\r\n    1. Start with using your grep tool for finding keywords.\r\n    2. Optionally, use glob for file patterns\r\n    3. LS and Glob your way to victory as well!\r\n\r\n    ### Refine by Language/Framework\r\n    - **JavaScript/TypeScript**: Look in src/, lib/, components/, pages/, api/\r\n    - **Python**: Look in src/, lib/, pkg/, module names matching feature\r\n    - **Go**: Look in pkg/, internal/, cmd/\r\n    - **General**: Check for feature-specific directories - I believe in you, you are a smart cookie :)\r\n\r\n    ### Common Patterns to Find\r\n    - `*service*`, `*handler*`, `*controller*` - Business logic\r\n    - `*test*`, `*spec*` - Test files\r\n    - `*.config.*`, `*rc*` - Configuration\r\n    - `*.d.ts`, `*.types.*` - Type definitions\r\n    - `README*`, `*.md` in feature dirs - Documentation\r\n\r\n    ## Output Format\r\n\r\n    Structure your findings like this:\r\n\r\n    ```\r\n    ## File Locations for [Feature/Topic]\r\n\r\n    ### Implementation Files\r\n    - `src/services/feature.js` - Main service logic\r\n    - `src/handlers/feature-handler.js` - Request handling\r\n    - `src/models/feature.js` - Data models\r\n\r\n    ### Test Files\r\n    - `src/services/__tests__/feature.test.js` - Service tests\r\n    - `e2e/feature.spec.js` - End-to-end tests\r\n\r\n    ### Configuration\r\n    - `config/feature.json` - Feature-specific config\r\n    - `.featurerc` - Runtime configuration\r\n\r\n    ### Type Definitions\r\n    - `types/feature.d.ts` - TypeScript definitions\r\n\r\n    ### Related Directories\r\n    - `src/services/feature/` - Contains 5 related files\r\n    - `docs/feature/` - Feature documentation\r\n\r\n    ### Entry Points\r\n    - `src/index.js` - Imports feature module at line 23\r\n    - `api/routes.js` - Registers feature routes\r\n    ```\r\n\r\n    ## Important Guidelines\r\n\r\n    - **Don't read file contents** - Just report locations\r\n    - **Be thorough** - Check multiple naming patterns\r\n    - **Group logically** - Make it easy to understand code organization\r\n    - **Include counts** - \"Contains X files\" for directories\r\n    - **Note naming patterns** - Help user understand conventions\r\n    - **Check multiple extensions** - .js/.ts, .py, .go, etc.\r\n\r\n    ## What NOT to Do\r\n\r\n    - Don't analyze what the code does\r\n    - Don't read files to understand implementation\r\n    - Don't make assumptions about functionality\r\n    - Don't skip test or config files\r\n    - Don't ignore documentation\r\n    - Don't critique file organization or suggest better structures\r\n    - Don't comment on naming conventions being good or bad\r\n    - Don't identify \"problems\" or \"issues\" in the codebase structure\r\n    - Don't recommend refactoring or reorganization\r\n    - Don't evaluate whether the current structure is optimal\r\n\r\n    ## REMEMBER: You are a documentarian, not a critic or consultant\r\n\r\n    Your job is to help someone understand what code exists and where it lives, NOT to analyze problems or suggest improvements. Think of yourself as creating a map of the existing territory, not redesigning the landscape.\r\n\r\n    You're a file finder and organizer, documenting the codebase exactly as it exists today. Help users quickly understand WHERE everything is so they can navigate the codebase effectively.\r\n\r\n    You can respond in two ways:\r\n    1. **To search**: Return a `LocatorDecision` with `tool` populated (single tool, and optionally `explanation`) when you need to execute a search\r\n    2. **To report findings**: Return a `LocatorDecision` with `findings` populated (structured markdown output) when you have results from tools and want to organize them into the final output format\r\n\r\n    Analyze the conversation history and determine which approach to take. If you need to search, return a single tool. Execute one tool at a time. If you have search results to organize, return findings in the structured format described above.\r\n\r\n    **Important**: Tool results from previous tool executions are included in the message history as system messages. Look for system messages that contain \"Tool executed:\" to see previous tool results. You can use information from all previous tool results when making decisions.\r\n\r\n    {{ ctx.output_format }}\r\n\r\n    Conversation history:\r\n    {% for msg in messages %}\r\n    {{ _.role(msg.role) }} {{ msg.content }}\r\n    {% endfor %}\r\n    \"#\r\n}\r\n\r\ntest code_locator_basic {\r\n    functions [CodeLocator]\r\n    args {\r\n        messages [{\r\n            role \"user\"\r\n            content \"I want to find the code for the feature 'user authentication'\"\r\n        }]\r\n    }\r\n}\r\n\r\ntest code_locator_with_tool_result {\r\n    functions [CodeLocator]\r\n    args {\r\n        messages [\r\n            {\r\n                role \"user\"\r\n                content \"I want to find the code for the feature 'user authentication'\"\r\n            }\r\n            {\r\n                role \"assistant\"\r\n                content #\"\r\n                {\"explanation\": \"I'll start by searching for authentication-related code using the term 'auth', which is the most common keyword used in authentication systems. This will help identify files that contain authentication logic, services, handlers, or related functionality.\",\r\n                  \"tool\": {\r\n                    \"name\": \"grep\",\r\n                    \"pattern\": \"auth\",\r\n                    \"path\": null,\r\n                    \"type\": null\r\n                  },\r\n                  \"findings\": null\r\n                }\r\n                \"#\r\n            }\r\n            {\r\n                role \"system\"\r\n                content \"Tool executed: grep\\nArguments: {\\\"name\\\":\\\"grep\\\",\\\"pattern\\\":\\\"auth\\\",\\\"path\\\":null,\\\"type\\\":null}\\nResult: Found 15 matches across 8 files:\\n- src/auth/authenticator.js (3 matches)\\n- src/auth/login-handler.js (5 matches)\\n- src/models/user.js (2 matches)\\n- src/middleware/auth-middleware.js (3 matches)\\n- tests/auth/authenticator.test.js (1 match)\\n- tests/auth/login-handler.test.js (1 match)\\n- config/auth.config.js (0 matches, but file contains 'auth')\\n- docs/auth/README.md (0 matches, but file contains 'authentication')\"\r\n            }\r\n        ]\r\n    }\r\n}",
    "codeact.baml": "class CodeActAgentDecision {\r\n  message Message?\r\n  code string? @description(\"The clojure code to execute\")\r\n}\r\n\r\nfunction CodeActAgent(messages: Message[], code: string?, code_result: string?) -> CodeActAgentDecision {\r\n  client \"GLMCodingA\"\r\n  // client \"LMStudioQWen3Coder\"\r\n  prompt #\"\r\n    {{ _.role(\"system\") }}\r\n\r\n    You are a CodeAct agent that can explore a Clojure codebase and execute code. Analyze the conversation history, the latest code execution, and its result to decide what action to take next. You can:\r\n    1. Respond with a Message only (set message, leave code empty)\r\n    2. Respond with a Message and code (set both message and code)\r\n    3. Use code only without a message (leave message null, set code)\r\n\r\n    You can write and execute Clojure code directly to explore the codebase, read files, search for patterns, and perform any other operations you need. Use standard Clojure functions and libraries to accomplish your tasks.\r\n\r\n    IMPORTANT: You have access to predefined helper functions in the `com.dx.baml-client.tools.tools` namespace. You can use these functions in your code by requiring the namespace. The available functions are:\r\n\r\n    ```clojure\r\n    {{PredefinedFunctions()}}\r\n    ```\r\n\r\n    {{ ctx.output_format }}\r\n\r\n    Conversation history:\r\n    {% for msg in messages %}\r\n    {{ _.role(msg.role) }} {{ msg.content }}\r\n    {% endfor %}\r\n\r\n    {{ _.role(\"system\") }}\r\n    {% if code %}\r\n    The following code was just executed:\r\n    ```clojure\r\n    {{ code }}\r\n    ```\r\n\r\n    {% if code_result %}\r\n    Code execution result:\r\n    {{ code_result }}\r\n    {% else %}\r\n    Code execution completed (no result returned).\r\n    {% endif %}\r\n    \r\n    Please analyze this result and decide what to do next. You may need to:\r\n    - Provide a final answer if the task is complete\r\n    - Execute additional code if more work is needed\r\n    - Fix errors if the code failed\r\n    - Continue with the next step in a multi-step process\r\n    {% elif code_result %}\r\n    Previous code execution result:\r\n    {{ code_result }}\r\n    \r\n    Please analyze this result and decide what to do next.\r\n    {% else %}\r\n    No code has been executed yet. Based on the conversation history, decide what action to take next.\r\n    {% endif %}\r\n  \"#\r\n}\r\n\r\ntest codeact_list_directory {\r\n  functions [CodeActAgent]\r\n  args {\r\n    messages [{\r\n      role \"user\"\r\n      content \"what is in current dir\"\r\n    }]\r\n  }\r\n}\r\n\r\ntest codeact_after_ls_execution {\r\n  functions [CodeActAgent]\r\n  args {\r\n    messages [{\r\n      role \"user\"\r\n      content \"how many files in current dir\"\r\n    }]\r\n    code \"(ls)\"\r\n    code_result \"file1.clj\\nfile2.clj\\ndirectory1\\ndirectory2\"\r\n  }\r\n  @@assert({{ this.message is not none and \"2\" in this.message.content }})\r\n}\r\n\r\ntest codeact_list_namespace_functions {\r\n  functions [CodeActAgent]\r\n  args {\r\n    messages [{\r\n      role \"user\"\r\n      content \"what functions in the current namespace\"\r\n    }]\r\n  }\r\n  @@assert({{ this.code is not none and (\"ns-publics\" in this.code or \"ns-map\" in this.code or \"*ns*\" in this.code) }})\r\n}\r\n\r\ntest codeact_explicit_create_celsius_to_fahrenheit {\r\n  functions [CodeActAgent]\r\n  args {\r\n    messages [{\r\n      role \"user\"\r\n      content \"create a celsius to fahrenheit function\"\r\n    }]\r\n  }\r\n  @@assert({{ this.code is not none and (\"defn\" in this.code or \"def\" in this.code) and (\"celsius\" in this.code or \"Celsius\" in this.code or \"fahrenheit\" in this.code or \"Fahrenheit\" in this.code or \"9/5\" in this.code or \"* 9\" in this.code or \"+ 32\" in this.code) }})\r\n}\r\n\r\ntest codeact_use_predefined_read_file {\r\n  functions [CodeActAgent]\r\n  args {\r\n    messages [{\r\n      role \"user\"\r\n      content \"read the file /path/to/example.clj\"\r\n    }]\r\n  }\r\n  @@assert({{ this.code is not none and (\"read-file\" in this.code or \"com.dx.baml-client.tools.tools\" in this.code or \"baml-client.tools.tools\" in this.code) }})\r\n}\r\n\r\ntest codeact_use_predefined_read_file_retry {\r\n  functions [CodeActAgent]\r\n  args {\r\n    messages [{\r\n      role \"user\"\r\n      content \"read the file /path/to/example.clj\"\r\n    }\r\n    {\r\n      role \"assistant\"\r\n      content #\"\r\n      ```clojure\r\n      (require '[com.dx.baml-client.tools.tools :as tools])\r\n      (tools/read-file \"/path/to/example.clj\")\r\n      ```\r\n      \"#\r\n    }\r\n    {\r\n      role \"user\"\r\n      content \"parse result error, if you want to execute code, please answer in JSON with key `code`\"\r\n    }\r\n    ]\r\n  }\r\n  @@assert({{ this.code is not none and (\"read-file\" in this.code or \"com.dx.baml-client.tools.tools\" in this.code or \"baml-client.tools.tools\" in this.code) }})\r\n}\r\n",
    "generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\n// generator openapi {\n//     // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n//     output_type \"rest/openapi\"\n\n//     // Where the generated code will be saved (relative to baml_src/)\n//     output_dir \"../\"\n\n//     // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n//     // The BAML VSCode extension version should also match this version.\n//     version \"0.213.0\"\n\n//     // 'baml-cli generate' will run this after generating openapi.yaml, to generate your OpenAPI client\n//     // This command will be run from within $output_dir/baml_client\n//     // on_generate \"npx @openapitools/openapi-generator-cli generate -i openapi.yaml -g clojure -o .\"\n// }\n\ngenerator python {\n    output_type \"python/pydantic\"\n    output_dir \"../\"\n    version \"0.215.2\"\n}",
    "pre-functions.baml": "template_string PredefinedFunctions() #\"\r\n(ns com.dx.baml-client.tools.tools\r\n  (:require\r\n   [com.dx.baml-client.tools.read-file :as read-file]))\r\n\r\n(defn read-file\r\n  \"Read and return refined file content.\r\n   \r\n   Args:\r\n   - path: Absolute file path (string, required)\r\n   - line-range: Optional map with :start and :end keys (both integers, 1-indexed)\r\n   \r\n   Returns:\r\n   - Refined file content as string\"\r\n  [path & [line-range]]\r\n  (read-file/invoke-read-file path line-range))\r\n\"#\r\n",
    "tool_use.baml": "class Message {\r\n  role \"user\" | \"assistant\" | \"system\"\r\n  content string\r\n}\r\n\r\nclass AddTool {\r\n  name \"add\"\r\n  a int\r\n  b int\r\n}\r\n\r\nclass SubtractTool {\r\n  name \"subtract\"\r\n  a int\r\n  b int\r\n}\r\n\r\nclass ToolCall {\r\n  name string\r\n  args string\r\n  result string\r\n}\r\n\r\nclass ActionDecision {\r\n  message Message?\r\n  tools (AddTool | SubtractTool)[]\r\n}\r\n\r\nfunction DecideAction(messages: Message[], tool: ToolCall?) -> ActionDecision {\r\n  client \"LMStudioQWen3Coder\"\r\n  prompt #\"\r\n    {{ _.role(\"system\") }}\r\n\r\n    Analyze the conversation history and decide what action to take. You can:\r\n    1. Respond with a Message only (set message, leave tools empty)\r\n    2. Respond with a Message and use tools (set both message and tools)\r\n    3. Use tools only without a message (leave message null, set tools)\r\n\r\n    Available tools:\r\n    - AddTool: Adds two numbers (a and b)\r\n    - SubtractTool: Subtracts two numbers (a and b)\r\n\r\n    {{ ctx.output_format }}\r\n\r\n    Use tools when the user's request requires calculations. Include a message if you need to provide context, explanations, or conversational responses.\r\n\r\n    Conversation history:\r\n    {% for msg in messages %}\r\n    {{ _.role(msg.role) }} {{ msg.content }}\r\n    {% endfor %}\r\n\r\n    {{ _.role(\"system\") }}\r\n    {% if tool %}\r\n    A tool was just executed:\r\n    - Tool name: {{ tool.name }}\r\n    - Tool arguments: {{ tool.args }}\r\n    - Tool result: {{ tool.result }}\r\n    \r\n    Please process this result and respond appropriately. You may need to use additional tools or provide a final answer.\r\n    {% endif %}\r\n  \r\n  \"#\r\n}\r\n\r\ntest decide_action_single_tool {\r\n  functions [DecideAction]\r\n  args {\r\n    messages [{\r\n      role \"user\"\r\n      content \"I want to add 1 and 2\"\r\n    }]\r\n  }\r\n  @@assert({{ this.tools|length == 1 }})\r\n  @@assert({{ this.tools[0].name == \"add\" }})\r\n}\r\n\r\ntest decide_action_multiple_tools {\r\n  functions [DecideAction]\r\n  args {\r\n    messages [{\r\n      role \"user\"\r\n      content \"I want to add 1 and 2, then subtract 3 from 4\"\r\n    }]\r\n  }\r\n  @@assert({{ this.tools|length >= 2 }})\r\n}\r\n\r\ntest decide_action_with_tool_result {\r\n  functions [DecideAction]\r\n  args {\r\n    messages [{\r\n      role \"user\"\r\n      content \"I want to add 1 and 2\"\r\n    }]\r\n    tool {\r\n      name \"add\"\r\n      args \"{:a 1, :b 2}\"\r\n      result \"3\"\r\n    }\r\n  }\r\n  @@assert({{ this.message is not none }})\r\n  @@assert({{ this.message.content|length > 0 }})\r\n}\r\n\r\ntest decide_action_second_turn {\r\n  functions [DecideAction]\r\n  args {\r\n    messages [\r\n    {\r\n      role \"user\"\r\n      content \"hello\"\r\n    }\r\n    {\r\n      role \"assistant\"\r\n      content \"Hello! How can I help you today?\"\r\n    }\r\n    {\r\n      role \"user\"\r\n      content \"great\"\r\n    }]\r\n    tool null\r\n  }\r\n}",
}

def get_baml_files():
    return _file_map